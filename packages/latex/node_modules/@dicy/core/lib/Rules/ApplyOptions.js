'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _File = require('../File');

var _File2 = _interopRequireDefault(_File);

var _Rule = require('../Rule');

var _Rule2 = _interopRequireDefault(_Rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ApplyOptions extends _Rule2.default {
  // ApplyOptions runs in both the initialize and execute phases so that
  // instance options will be seen in the initialize phase.
  run() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // Save the old options so we can tell if they have changed.
      const previousOptions = _lodash2.default.cloneDeep(_this.state.options);

      yield _this.doAssignOptions();
      _this.checkForConfigurationChange(previousOptions);

      return true;
    })();
  }

  doAssignOptions() {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      // All the possible sources of configuration data with low priority first.
      const optionPaths = ['$HOME/.dicy.yaml-ParsedYAML', 'dicy.yaml-ParsedYAML', '$NAME.yaml-ParsedYAML', '$BASE-ParsedLaTeXMagic', 'dicy-instance.yaml-ParsedYAML'];

      const inputs = yield _this2.getResolvedInputs(optionPaths);
      const optionSet = inputs.map(function (file) {
        return file.value || {};
      });
      const globalOptions = (0, _assign2.default)({}, ...optionSet);

      // Remove the user options if ignoreUserOptions is set.
      if (globalOptions.ignoreUserOptions) {
        _this2.info('Ignoring user options since `ignoreUserOptions` is set.');
        optionSet.shift();
      }

      // Reset the options and assign from frrom the inputs
      _this2.state.resetOptions();

      for (const options of optionSet) {
        _this2.assignOptions(options);
      }
    })();
  }

  checkForConfigurationChange(previousOptions) {
    // Ignore options that don't actually change the build.
    const matcher = (objValue, srcValue, key, object, source) => {
      const schema = this.state.optionSchema.get(key.toString());
      if (schema && schema.noInvalidate) return true;
    };

    if (!_lodash2.default.isMatchWith(this.state.options, previousOptions, matcher)) {
      const rules = (0, _from2.default)(this.rules).filter(rule => rule.command !== 'load' || rule.phase === 'finalize');

      if (rules.length !== 0) {
        // Something has changed so remove rules that are not load rules or are
        // in the finalize phase.
        this.warning('Options have changed. Resetting all rules.');
        for (const rule of rules) {
          this.state.removeRule(rule);
        }
      }
    }
  }
}
exports.default = ApplyOptions;
ApplyOptions.commands = new _set2.default(['load']);
ApplyOptions.phases = new _set2.default(['initialize', 'execute']);
ApplyOptions.alwaysEvaluate = true;
ApplyOptions.ignoreJobName = true;
ApplyOptions.description = 'Apply options from YAML files and any LaTeX magic comments found in source file.';